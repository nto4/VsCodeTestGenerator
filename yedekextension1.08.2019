// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';
import * as path from 'path';
//import { create } from 'domain';
import * as fs from 'fs';
import { parse } from 'node-html-parser';
//var x = require ("./../spec-template.txt");
var countButtonTag:number;
var counInputTag:number;
export function activate(context: vscode.ExtensionContext) {

	//console.log('Congratulations, your extension  is now active!');
	/*vscode.workspace.openTextDocument(uri).then((document) => {
		let text = document.getText();
	  });
	  */
	

	/*	var DOMParser = require('xmldom').DOMParser;
var doc = new DOMParser().parseFromString(
   text
    ,'text/xml');
doc.documentElement.setAttribute('x','y');
doc.documentElement.setAttributeNS('./lite','c:x','y2');
var nsAttr = doc.documentElement.getAttributeNS('./lite','x');
//console.log(nsAttr);
//console.log(doc);
*/

	let disposable = vscode.commands.registerCommand('extension.action', () => {

		if (vscode.window.activeTextEditor != undefined) {
			var currentlyOpenTabfilePath = (vscode.window.activeTextEditor.document.fileName);
			var fileNameArray = currentlyOpenTabfilePath.split("\\");
			var currentFileName = fileNameArray[(fileNameArray.length) - 1];

			var withOutEndfixFileNameAndPrefix = currentFileName.split(".");

			var xxx = withOutEndfixFileNameAndPrefix[0];

			currentFileName = xxx + '.spec.js';

			{
				if (vscode.window.activeTextEditor != undefined) {
					var relativePath = (vscode.window.activeTextEditor.document.fileName);
					vscode.workspace.openTextDocument(relativePath).then((document) => {
						let text = document.getText();
						countButtonTag = (text.match(/button/g) || []).length;
						console.log(countButtonTag);
						counInputTag = (text.match(/input/g) || []).length;
						console.log(counInputTag);
					});
				}
				
					let clickButton = "\n element(by.id('TypeHere')).click(); \n";
					let sendKey ="\n element(by.name('Ad')).sendKeys('mehmettest'); \n";
					let expectKey ="n\ expect(element(by.id('x')).getText()).toEqual('mehmettest'); \n";
				let describe = " describe('Type Describe', function ()";
				let itit = "{\n	it('Type fetch details', async function () {";
				let angularCheck = "\n 	browser.waitForAngular";
				let headerCheck = "\n		await browser.get('http://localhost:TypeHere/');\n\n	\n		await expect(browser.getTitle()).toEqual('TypeHere');	";
				let ititEnd = "		\n\n	});";
				let describeEnd = "\n});";
				//button element number =  countButtonTag/2
				//input element number = 	counInputTag
				function testGenerate(counInputTag :number,countButtonTag:number) {

				var	belge :string;
				let clickButton = "\n			element(by.id('TypeHere')).click(); \n";
					let sendKey ="\n   			element(by.name('TypeHere')).sendKeys('TypeHere'); \n";
					let expectKey ="\n 			expect(element(by.id('TypeHere')).getText()).toEqual('TypeHere'); \n";
				let describe = "describe('Type Describe', function ()";
				let itit = "{\n	it('Type fetch details', async function () {";
				let angularCheck = "\n 		browser.waitForAngular";
				let headerCheck = "\n		await browser.get('http://localhost:TypeHere/');\n	\n		await expect(browser.getTitle()).toEqual('TypeHere');	";
				let ititEnd = "		\n\n	});";
				let describeEnd = "\n});";
				var belgeSendKey:string ="";
				var belgeExpectKey:string="";
				//var belgeSendKeyTempForLoop:string="";
				for (let index = 0; index < counInputTag; index++) {
					belgeSendKey  += sendKey;
					belgeExpectKey +=expectKey;
					
				}
				var belgeBody:string= belgeSendKey + clickButton + belgeExpectKey;
				belge = describe +
				 itit 
				 + angularCheck 
				 + headerCheck



				 + belgeBody 



				 + ititEnd 
				 + describeEnd;
					return belge;
					
				}
				//console.log(testGenerate(2,2));
				var metin =testGenerate(counInputTag,countButtonTag);
				var metin3 = describe +
				 itit 
				 + angularCheck 
				 + headerCheck



				 + clickButton 



				 + ititEnd 
				 + describeEnd;
			}
			//console.log(metin);
			vscode.window.showInformationMessage('Action Called');
			let folderPath = vscode.workspace.rootPath;
			if (folderPath !== undefined) {
				let filePath = ("untitled:" + folderPath);
				//console.log(filePath);
				if (vscode.workspace.rootPath != undefined) {
					const newFile = vscode.Uri.parse('untitled:' + path.join(vscode.workspace.rootPath, currentFileName));
					//console.log(newFile);
					vscode.workspace.openTextDocument(newFile).then(document => {
						const edit = new vscode.WorkspaceEdit();
						edit.insert(newFile, new vscode.Position(0, 0), metin);
						return vscode.workspace.applyEdit(edit).then(success => {
							if (success) {
								vscode.window.showTextDocument(document);
							} else {
								vscode.window.showInformationMessage('Error!');
							}
						});
					});
				}
				//sniplet
				//vscode.workspace.openTextDocument().then(doc => vscode.window.showTextDocument(doc));//.then(doc => vscode.workspace.applyEdit.name);

			}
			else {
				vscode.window.showInformationMessage('Error!  Unable to combine file path extension and name');
			}

		}
		else {
			vscode.window.showInformationMessage('Error! cant find path');
		}
		vscode.workspace.findFiles
	});


	context.subscriptions.push(disposable);
}

// this method is called when your extension is deactivated
export function deactivate() { }


